{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
{\fonttbl\f0\fnil\fcharset0 Cochin;}
{\colortbl;\red255\green255\blue255;}
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\fi360\sl288\slmult1\pardirnatural

\f0\fs28 \cf0 What other flexibility do we get? We can safely apply our monoid in parallel.\
\
Our counting or hyperloglog-ing, or looking for distinct visitors can all be safely split up into multiple jobs, and combined back into a single value.  And we know that because of laws.\
\
This is something else that functional programming has done for us. To be a monoid you have to have the structure I mentioned, but you also need to follow the monoid laws. And there are two laws.  And the laws are really what make something a monid, I guess.\
\
The laws look like this.  For our addition monid we demand that applying empty to a value has no effect. And when adding, we demand that it doesn\'92t matter how to group those operations.  So 1 plus 2, when added to three, is the same as 1 added to the combined 2 and 3.\
\
The same must apply for our string concatination monoid.  Here our empty value is the empty string.   \
\
And this has to hold for any values. So any a plus the empty value is a.  Any a plus b, then plus is c\'85.\
\
The\'92s laws have names:  identity and associativity\
And more generally, in the language of the interface I\'92ve been using we say: a combined with empty is a, and a combined with b combined with c, is the same as\'85.well, you get the idea.   \
\
There\'92s no police enforcing that law. Typically, when you write an instance, you\'92re write a test to go with it. Usually you\'92ll do that with property based-testing, where you use a library that will generate edge cases and arbitrary values, and test your monoid.\
\
And I think you can see that providing we obey those laws, our monoid - regardless of what it does \'97 will parallelize nicely.  It doesn\'92t matter if you do this in one thread of execution or many, you\'92re going to get the same answer. And that\'92s possible because the law of the data structure.\
}